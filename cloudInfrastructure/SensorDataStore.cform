{
  "AWSTemplateFormatVersion": "2010-09-09",
  "Description": "Sensor API",
  "Parameters": {
    "DynamoDBTableName": {
        "Description": "Name of the DynamoDB table to store the captured data",
        "Type": "String",
        "Default": "SensorData"
    }
  },
  "Resources": {
    "RetrieveFromDynamoDB": {
      "Type": "AWS::Lambda::Function",
      "Properties": {
        "Handler": "index.handler",
        "Role": { "Fn::GetAtt" : ["LambdaExecutionRole", "Arn"] },
        "Timeout": 6,
        "Code": {
          "ZipFile":  { "Fn::Join": ["\n", [
            "const AWS = require('aws-sdk');\n",
            "AWS.config.update({region: process.env.AWS_REGION}); \n",
            "const dynamo = new AWS.DynamoDB.DocumentClient({apiVersion: '2012-08-10'});\n",
            "exports.handler = async (event, context) => {\n",
            "  console.log(JSON.stringify(event));\n",
            "  const parse = (data) => {\n",
            "    if (typeof data === 'object') return data;\n",
            "      else if (typeof data === 'string') return JSON.parse(data);\n",
            "  };\n",
            "  const getData = (params, reduceFactor, reject, resolve) => {\n",
            "    return \n",
            "    \n",
            "  };\n",
            "  if(event.requestContext.http.method != 'POST') {\n",
            "    const resp = {\n",
            "      statusCode: 200, \n",
            "        body:{\n",
            "          ok: false,\n",
            "          message: 'Bad HTTP method'\n",
            "        }\n",
            "    };\n",
            "      console.log('response: ' + JSON.stringify(resp));\n",
            "    return JSON.stringify(resp);\n",
            "  }\n",
            "  if(!event.body){\n",
            "    const resp = {\n",
            "      statusCode: 200, \n",
            "        body:{\n",
            "          ok: false,\n",
            "          message: 'You must provide a HTTP body'\n",
            "        }\n",
            "    };\n",
            "    console.log('response: ' + JSON.stringify(resp));\n",
            "    return JSON.stringify(resp);\n",
            "  }\n",
            "  const body = parse(event.body);\n",
            "  if(!body.fromTimestamp){\n",
            "    const resp = {\n",
            "      statusCode: 200, \n",
            "        body:{\n",
            "          ok: false,\n",
            "          message: 'You must provide a fromTimestamp json parameter'\n",
            "        }\n",
            "    };\n",
            "    console.log('response: ' + JSON.stringify(resp));\n",
            "    return JSON.stringify(resp);\n",
            "  }\n",
            "  const getEntries = (fromTimestamp) => {\n",
            "    console.log(fromTimestamp);\n",
            "    const params = {\n",
            {"Fn::Sub": ["            TableName: '${TableName}',\n", {"TableName": {"Ref": "DynamoDBTableName"}}]},
            "        FilterExpression: '#timestamp > :from',\n",
            "        ExpressionAttributeNames: {\n",
            "          '#timestamp': 'timestamp',\n",
            "        },\n",
            "        ExpressionAttributeValues: {\n",
            "          ':from': fromTimestamp\n",
            "        }\n",
            "    };\n",
            "    return new Promise((resolve, reject) => {\n",
            "      dynamo.scan(params, (error, data) => {\n",
            "        if(error){\n",
            "          reject({ok: false, message: error});\n",
            "        }\n",
            "        else{\n",
            "            const reduceFactor = Math.floor((((new Date()).getTime() / 1000) - fromTimestamp) / 3600.0) + 1;\n",
            "            // resolve({ok: true, message: data});\n",
            "            console.log(reduceFactor);\n",
            "            // console.log(data);\n",
            "            let newData = [];\n",
            "            // Reduce the array by some factor\n",
            "            for (let i = 0; i < data.Items.length; i=i+reduceFactor) {\n",
            "              console.log(data.Items[i]);\n",
            "              newData.push(data.Items[i]);\n",
            "            }\n",
            "            console.log(newData);\n",
            "            resolve({ok: true, message: newData});\n",
            "        }\n",
            "      });\n",
            "    });\n",
            "  };\n",
            "  const result = await getEntries(body.fromTimestamp)\n",
            "      .catch((error) => console.log(error));\n",
            "  const response = {\n",
            "      statusCode: 200, \n",
            "      body: JSON.stringify(result)\n",
            "  };\n",
            "  console.log('response: ' + JSON.stringify(response));\n",
            "  return JSON.stringify(response);\n",
            "};\n"
          ]]}
        },
        "Runtime": "nodejs14.x"
      },
      "DependsOn": "DynamoDBTable"
    },
    "SaveToDynamoDB": {
      "Type": "AWS::Lambda::Function",
      "Properties": {
        "Handler": "index.handler",
        "Role": { "Fn::GetAtt" : ["LambdaExecutionRole", "Arn"] },
        "Code": {
          "ZipFile":  { "Fn::Join": 
            ["", [
              "const AWS = require('aws-sdk');\n",
              "AWS.config.update({region: process.env.AWS_REGION}); \n",
              "const dynamo = new AWS.DynamoDB.DocumentClient({apiVersion: '2012-08-10'});\n",
              "exports.handler = async (event, context) => {\n",
              "    console.log(JSON.stringify(event));\n",
              "    const parse = (data) => {\n",
              "        if (typeof data === 'object') return data;\n",
              "        else if (typeof data === 'string') return JSON.parse(data);\n",
              "    };\n",
              "    const duePoint = (t, h) => ((h/100)**(1/8))*(112 + (0.9*t)) + (0.1*t) - 112 + 273.16;\n",
              "    const humidex = (t, h) => t + 0.5555*(6.11 * Math.exp(5417.7530 * ((1/273.16) - (1/duePoint(t,h))))-10);\n",
              "    const publishSNS = (message) =>\n",
              "    {\n",
              "        var sns = new AWS.SNS();\n",
              "        var params = {\n",
              "            Message: message,\n",
              "            TopicArn: '", { "Ref" : "SensorAlertTopic"}, "'\n",
              "        };\n",
              "        sns.publish(params, context.done);\n",
              "    };\n",
              "    const addEntry = (timestamp, value) => {\n",
              "        const params = {\n",
              {"Fn::Sub": ["            TableName: '${TableName}',\n", {"TableName": {"Ref": "DynamoDBTableName"}}]},
              "            Item: {\n",
              "                deviceID: 1,\n",
              "                timestamp: timestamp,\n",
              "                value: value\n",
              "            },\n",
              "        };\n",
              "      return new Promise((resolve, reject) => {\n",
              "        dynamo.put(params, (error, data) => {\n",
              "            if(error){\n",
              "                reject(error);\n",
              "            }\n",
              "            else{\n",
              "                resolve(data);\n",
              "            }\n",
              "        });\n",
              "      });\n",
              "    };\n",
              "    let successes = 0;\n",
              "    let failures = 0;\n",
              "    if(!event.body) return {statusCode: 400, message: 'You must provide a JSON body'};\n",
              "    let heighestHumidex = 0;\n",
              "    let lowestTemp = 100;\n",
              "    for (const [timestamp, value] of Object.entries(parse(event.body))) {\n",
              "        const h = humidex(value.Temperature, value.Humidity);\n",
              "        heighestHumidex = (h > heighestHumidex ? h : heighestHumidex);\n",
              "        lowestTemp = (value.Temperature < lowestTemp ? value.Temperature : lowestTemp);\n",
              "        await addEntry(Math.floor(new Date(timestamp).getTime()/1000), value)\n",
              "            .then(() => successes = successes + 1)\n",
              "            .catch((error) => {failures = failures + 1; console.log(error)});\n",
              "    }\n",
              "    console.log('Humidex: ' + heighestHumidex.toFixed(2));\n",
              "if(heighestHumidex > 25)\n",
              "       publishSNS('Humidex is too high: ' + heighestHumidex.toFixed(2) + '.');\n",
              "if(lowestTemp < 19.5) \n",
              "       publishSNS('Temperature is too low: ' + lowestTemp.toFixed(2) + 'C.');\n",
              "    \n",
              "    const response = {\n",
              "        statusCode: 200,\n",
              "        body: JSON.stringify({\n",
              "            success: failures === 0\n",
              "        })\n",
              "    };\n",
              "    console.log('response: ' + JSON.stringify(response));\n",
              "    return response;\n",
              "};\n"
            ]]
          }
        },
        "Runtime": "nodejs14.x"
      },
      "DependsOn": "DynamoDBTable"
    },
    "DynamoDBTable": {
      "Type": "AWS::DynamoDB::Table",
      "Properties": {
        "TableName": {
          "Ref": "DynamoDBTableName"
        },
        "AttributeDefinitions": [
          {
            "AttributeName": "deviceID",
            "AttributeType": "N"
          },
          {
            "AttributeName": "timestamp",
            "AttributeType": "N"
          }
        ],
        "KeySchema": [
          {
            "AttributeName": "deviceID",
            "KeyType": "HASH"
          },
          {
            "AttributeName": "timestamp",
            "KeyType": "RANGE"
          }
        ],
        "ProvisionedThroughput": {
          "ReadCapacityUnits": 2,
          "WriteCapacityUnits": 5
        }
      }
    },
    "SendDataApiGateway": {
      "Type": "AWS::ApiGatewayV2::Api",
      "Properties": {
        "Name": "Send Sensor Data",
        "Description": "A Proxy for the sensor data processor lambda function",
        "ProtocolType": "HTTP",
        "CredentialsArn": { "Fn::GetAtt" : ["ApiGatewayExecutionRole", "Arn"] },
        "Target": { "Fn::GetAtt" : ["SaveToDynamoDB", "Arn"] }
      }
    },
    "RetrieveDataApiGateway": {
      "Type": "AWS::ApiGatewayV2::Api",
      "Properties": {
        "Name": "Retrieve Sensor Data",
        "Description": "A Proxy for lambda function which retrieves data from the db",
        "ProtocolType": "HTTP",
        "CredentialsArn": { "Fn::GetAtt" : ["ApiGatewayExecutionRole", "Arn"] },
        "CorsConfiguration": {
          "AllowHeaders" : [ "content-type" ],
          "AllowMethods" : [ "POST", "OPTIONS" ],
          "AllowOrigins" : [ "*" ],
          "AllowCredentials": false,
          "MaxAge" : 0
        },
        "Target": { "Fn::GetAtt" : ["RetrieveFromDynamoDB", "Arn"] }
      }
    },
    "Logs": {
      "Type": "AWS::Logs::LogGroup",
      "Properties":{
        "LogGroupName": {
            "Fn::Join": ["", 
              [
              {
                "Ref": "SendDataApiGateway"
              },
              "access-logs"
            ]
          ]
        }
      }
    },
    "LambdaExecutionRole": {
      "Type": "AWS::IAM::Role",
      "Properties": {
        "AssumeRolePolicyDocument": {
          "Version": "2012-10-17",
          "Statement": [{ "Effect": "Allow", "Principal": {"Service": ["lambda.amazonaws.com"]}, "Action": ["sts:AssumeRole"] }]
        },
        "Path": "/",
        "Policies": [{
          "PolicyName": "root",
          "PolicyDocument": {
            "Version": "2012-10-17",
            "Statement": [
              { "Effect": "Allow", "Action": ["logs:*"], "Resource": "arn:aws:logs:*:*:*" },
              { "Effect": "Allow", "Action": ["dynamodb:PutItem", "dynamodb:Scan"], "Resource": "*" },
              { "Effect": "Allow", "Action": ["SNS:Publish"], "Resource": "*" }
            ]
          }
        }]
      }
    },
    "ApiGatewayExecutionRole": {
      "Type": "AWS::IAM::Role",
      "Properties": {
        "AssumeRolePolicyDocument": {
          "Version": "2012-10-17",
          "Statement": [{ "Effect": "Allow", "Principal": {"Service": ["apigateway.amazonaws.com"]}, "Action": ["sts:AssumeRole"] }]
        },
        "Path": "/",
        "Policies": [{
          "PolicyName": "root",
          "PolicyDocument": {
            "Version": "2012-10-17",
            "Statement": [
              { "Effect": "Allow", "Action": [
                "lambda:InvokeFunction",
                "lambda:InvokeAsync"
                ], "Resource": "*" }
            ]
          }
        }]
      }
    },
    "SensorAlertTopic": {
      "Type" : "AWS::SNS::Topic",
      "Properties" : {
          "DisplayName" : "Sensor Alert",
          "FifoTopic" : false,
          "TopicName" : "SensorAlert"
        }
    }
  },
  "Outputs":{
    "SendApiEndpoint" : {
      "Value" : {
        "Fn::Sub": "https://${SendDataApiGateway}.execute-api.ap-southeast-2.amazonaws.com"
      }
    },
    "RetrieveApiEndpoint" : {
      "Value" : {
        "Fn::Sub": "https://${RetrieveDataApiGateway}.execute-api.ap-southeast-2.amazonaws.com"
      }
    }
    
  }
}
